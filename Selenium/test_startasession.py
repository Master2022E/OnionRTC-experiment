# Generated by Selenium IDE
import traceback
from selenium.common import *

import pytest
import time
import json
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.common.action_chains import ActionChains
from selenium.webdriver.support import expected_conditions
from selenium.webdriver.support.wait import WebDriverWait
from selenium.webdriver.common.keys import Keys
from selenium.webdriver.common.desired_capabilities import DesiredCapabilities
from webdriver_manager.firefox import GeckoDriverManager
from selenium.webdriver.firefox.options import Options
from selenium.webdriver.firefox.service import Service

import logging
logging.basicConfig(
    format='%(asctime)s %(levelname)-8s %(message)s',
    level=logging.INFO,
    datefmt='%Y-%m-%d %H:%M:%S')

def selenium_execute_with_retry(execute, command,
                                params):
  """Run a single selenium command and retry once.
  The retry happens for certain errors that are likely to be resolved
  by retrying.
  """
  try:
    return execute(command, params)
  except Exception as e:
    if isinstance(e, ALWAYS_RETRY_EXCEPTIONS):
      # Retry
      time.sleep(1)
      return execute(command, params)
    else:
      raise

def selenium_wrapper(selenium_api):
  if not getattr(selenium_api, "_patched", False):
    orig_execute = selenium_api.execute

    def execute(driver_command, params=None):
      try:
        result = selenium_execute_with_retry(orig_execute, driver_command, params)
      except Exception:
        raise
      return result

    selenium_api.execute = execute
    selenium_api._patched = True

  return selenium_api


ALWAYS_RETRY_EXCEPTIONS = (
      ElementNotInteractableException,
      NoSuchWindowException,
      NoSuchElementException,
      NoSuchFrameException,
      NoSuchAttributeException,
      InvalidElementStateException,
      ElementNotVisibleException,
      TimeoutException
  )


class TestStartasession():
    def setup_method(self, method):
        webdriverOptions = Options()
        webdriverOptions.set_preference("media.navigator.permission.disabled", True)
        webdriverOptions.set_preference("media.peerconnection.ice.relay_only", True)
        webdriverOptions.headless = True


        # Setup Socks Proxy
        # https://stackoverflow.com/questions/60000480/how-to-use-only-socks-proxy-in-firefox-using-selenium
        webdriverOptions.set_preference("network.proxy.type", 1)
        webdriverOptions.set_preference("network.proxy.socks", "localhost")
        webdriverOptions.set_preference("network.proxy.socks_port", 9050)
        #webdriverOptions.update_preferences()



        browser = webdriver.Firefox(service=Service("/usr/bin/geckodriver"),options=webdriverOptions)
        self.driver = selenium_wrapper(browser)
        self.vars = {}
        self.vars["headless"] = webdriverOptions.headless
        self.vars["session_length_seconds"] = 20*60







    def teardown_method(self, method):
        if self.vars["headless"]:
            self.driver.quit()

        logging.info("Test done")

    def test_startasession(self):
        self.driver.get("about:webrtc")
        self.driver.set_window_size(1911, 1158)
        
        if self.driver.title == 'WebRTC Internals':
            # We are on the webRTC page
            ice_relay_only_str = "media.peerconnection.ice.relay_only"
            permission_disabled_str = "media.navigator.permission.disabled"

            relay_only , permissions = None, None

            if ice_relay_only_str in self.driver.page_source:
                relay_only = ice_relay_only_str+": true" in self.driver.page_source
            
            if permission_disabled_str in self.driver.page_source:
                permissions = permission_disabled_str+": true" in self.driver.page_source

            logging.info("Browser settings:"+ice_relay_only_str+":"+str(relay_only)+" - "+permission_disabled_str+":"+str(permissions))
        else:
            logging.warn("Was not able to go to about:webrtc to check permissions!!!")
            



        logging.info("Navigating to https://www.thomsen-it.dk..")
        self.driver.get("https://thomsen-it.dk")

        if self.driver.title == 'React App':
            # We are on the webRTC application page
            logging.info("Navigated to https://www.thomsen-it.dk..")

            # Starting test
            WebDriverWait(self.driver, 30).until(
                expected_conditions.visibility_of_element_located((By.CSS_SELECTOR, ".ip > .value")))
            WebDriverWait(self.driver, 30).until(
                expected_conditions.visibility_of_element_located((By.CSS_SELECTOR, ".country > .value")))
            self.vars["wanIp"] = self.driver.find_element(
                By.CSS_SELECTOR, ".ip > .value").text
            self.vars["country"] = self.driver.find_element(
                By.CSS_SELECTOR, ".country > .value").text
            self.vars["region"] = self.driver.find_element(
                By.CSS_SELECTOR, ".region > .value").text
            self.vars["city"] = self.driver.find_element(
                By.CSS_SELECTOR, ".city > .value").text
            self.driver.find_element(By.CSS_SELECTOR, ".username-input").click()
            self.vars["isp"] = self.driver.find_element(
                By.CSS_SELECTOR, ".isp > .value").text
            self.driver.find_element(By.CSS_SELECTOR, ".username-input").click()
            self.driver.find_element(
                By.CSS_SELECTOR, ".username-input").send_keys("username")
            self.driver.find_element(By.CSS_SELECTOR, ".room-input").click()
            self.driver.find_element(
                By.CSS_SELECTOR, ".room-input").send_keys("room")

            logging.info("\n" + self.vars["wanIp"] + " " + self.vars["country"] + " " +
                self.vars["region"] + " " + self.vars["city"] + " " + self.vars["isp"])
            self.driver.find_element(By.ID, "start-call").click()

            # Waiting for the call to start by checking if the video element is visible
            while "<td>kind</td><td></td>" in self.driver.page_source:
                time.sleep(2)
                logging.info("Waiting for the call to start..")

            logging.info(f"Waiting for {self.vars['session_length_seconds']} seconds to see if the call is working..")
            try:
                time.sleep(self.vars["session_length_seconds"])
            except KeyboardInterrupt:
                pass

        

        else:
            logging.warn("Was not able to confirm that we are on the React App!!!")



if __name__ == "__main__":
    t = TestStartasession()
    t.setup_method(None)
    t.test_startasession()
    t.teardown_method(None)
