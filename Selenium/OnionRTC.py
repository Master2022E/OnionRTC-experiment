#!/usr/bin/python3
# Generated by Selenium IDE
import traceback
from selenium.common import *

import pytest
import time
import json
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.common.action_chains import ActionChains
from selenium.webdriver.support import expected_conditions
from selenium.webdriver.support.wait import WebDriverWait
from selenium.webdriver.common.keys import Keys
from selenium.webdriver.common.desired_capabilities import DesiredCapabilities
from webdriver_manager.firefox import GeckoDriverManager
from selenium.webdriver.firefox.options import Options
from selenium.webdriver import firefox
from selenium.webdriver.firefox.service import Service

from misc.stem_event_streamer import setup_event_streamer, close_event_streamer


import pyfiglet
import sys
import argparse

import os
import logging
import logging.handlers

from misc.mongo_report import close_mongo_connection, create_client_report
import uuid


"""
Taken from
https://betterprogramming.pub/a-simple-addition-to-your-selenium-test-framework-that-makes-it-more-robust-and-reliable-e9cf97f52e78?gi=bb10badcc8b0
"""

def selenium_execute_with_retry(execute, command,
                                params):
  """Run a single selenium command and retry once.
  The retry happens for certain errors that are likely to be resolved
  by retrying.
  """
  try:
    return execute(command, params)
  except Exception as e:
    if isinstance(e, ALWAYS_RETRY_EXCEPTIONS):
      # Retry
      time.sleep(1)
      return execute(command, params)
    else:
      raise

def selenium_wrapper(selenium_api):
  if not getattr(selenium_api, "_patched", False):
    orig_execute = selenium_api.execute

    def execute(driver_command, params=None):
      try:
        result = selenium_execute_with_retry(orig_execute, driver_command, params)
      except Exception:
        raise
      return result

    selenium_api.execute = execute
    selenium_api._patched = True

  return selenium_api


ALWAYS_RETRY_EXCEPTIONS = (
      ElementNotInteractableException,
      NoSuchWindowException,
      NoSuchElementException,
      NoSuchFrameException,
      NoSuchAttributeException,
      InvalidElementStateException,
      ElementNotVisibleException,
      TimeoutException
  )

# Define a consistent state space for the test
states_str = ["setup_client","setup_browser","check_media","check_webrtc_settings",
              "starting_session","waiting_for_call","call_in_progress","call_ended",
              "teardown","done","error"]
states = dict()
for state in states_str:
    states[state] = state

# Report types
logging_str = ["NOT_SET","CLIENT_START","CLIENT_RUNNING", "CLIENT_END", "CLIENT_ERROR"]
logging_types = dict()
for type in logging_str:
    logging_types[type] = type




class OnionRTC():
    def setup_session(self):

        client_config = os.environ.get("CLIENT_CONFIG",None)

        parser = argparse.ArgumentParser(description='Run a WebRTC session on "https://thomsen-it.dk" using Selenium, optionally using onion routing.')

        # Positional arguments, meaning they are not required but can be used.
        # If you want to set the last one, then you need to set the previous ones as well.
        # Example: 'python3 test_startasession.py "Torben" "Room42" 2'
        # Results in: 'Namespace(client_username='Torben', room_id='Room42', session_length_seconds=2, proxy=False, headless=True, verbose=False)'
        parser.add_argument('client_username', metavar="client_username", nargs='?', type=str, default="client_username", help='The username of the client')
        parser.add_argument('room_id', metavar="room_id",nargs='?', type=str, default="room_id",  help='The room id that the client should join')
        parser.add_argument('session_length_seconds', metavar='N', type=int, nargs='?', default=60,
                            help='Sets the number of seconds a session should be running for')

        # Optional arguments
        parser.add_argument('-p','--proxy', action='store_const',
                            const=True, default=False,
                            help='Whether the browser should use the onion routing proxy') #FIXME: set default proxy to False 
        parser.add_argument('-r',metavar="int", type=int, dest="session_setup_retries", default=4,
                            help='How many times the session setup should be retried before failing the test')
        parser.add_argument("-c", dest="client_config", help="Sets a client config string. Defaults to env var $CLIENT_CONFIG", default=client_config)
        
        # Debug arguments
        parser.add_argument('-hl','--headless', action='store_const',
                            const=False, default=True,
                            help='Whether the browser should run in headless mode')
        parser.add_argument("-v", "--verbose", help="Print debug messages into debug.log file",
                            action="store_true", default=False)
        
        
        args = parser.parse_args()
        print(args)
        self.vars = args
        #self.vars.client_config = os.environ.get("CLIENT_CONFIG","NOT_SET")

        # How many ticks are there in rounds of waiting before reloading the page to do a new session setup
        # Related to session_setup_retries, which is default 4 and is the amount of rounds
        self.waiting_counter_max = 8

        self.vars.state = states["setup_browser"]


        logging_level = logging.INFO
        # Set the threshold for selenium to WARNING
        from selenium.webdriver.remote.remote_connection import LOGGER as seleniumLogger
        seleniumLogger.setLevel(logging.INFO)
        # Set the threshold for urllib3 to WARNING
        logging.getLogger("urllib3").setLevel(logging.CRITICAL)

        if args.verbose:
            logging_level = logging.DEBUG
            logging.getLogger("urllib3").setLevel(logging.INFO)





        console_handler = logging.StreamHandler(sys.stdout)
        console_handler.setLevel(logging.INFO)

        logging.basicConfig(
                format='%(asctime)s %(levelname)-8s %(message)s',
                level=logging_level,
                datefmt='%Y-%m-%d %H:%M:%S',
                    handlers=[
                    logging.FileHandler("debug.log"),
                    #logging.StreamHandler(), # Show everything on console
                    console_handler # Only show INFO and above on console
                ])


        webdriverOptions = Options()
        webdriverOptions.headless = self.vars.headless
        webdriverOptions.set_preference("media.navigator.permission.disabled", True)
        webdriverOptions.set_preference("media.peerconnection.ice.relay_only", True)
        


        # Setup Socks Proxy
        # https://stackoverflow.com/questions/60000480/how-to-use-only-socks-proxy-in-firefox-using-selenium
        if self.vars.proxy:
            webdriverOptions.set_preference("network.proxy.type", 1)
            webdriverOptions.set_preference("network.proxy.socks", "localhost")
            webdriverOptions.set_preference("network.proxy.socks_port", 9050)
            #webdriverOptions.update_preferences()



        browser = webdriver.Firefox(service=Service("/usr/bin/geckodriver"),options=webdriverOptions)
        driver = selenium_wrapper(browser)
        self.vars.driver = driver
        
        return self.vars







    def clean_up(self):
        if self.vars.state != states["error"]:
            self.vars.state = states["teardown"]

        if self.vars.headless:
            self.vars.driver.quit()
        logging.info("Test clean up complete")
        self.vars.state = states["done"]

        close_mongo_connection()

    def run_session(self):
        data = {'client_username':self.vars.client_username,
        "client_id": self.vars.client_id,
        "client_type": self.vars.client_config,
        "room_id": self.vars.room_id,
        "test_id": str(uuid.uuid4()),
        "logging_type": logging_types["NOT_SET"]}

        self.vars.state = states["check_media"]
        
        self.vars.driver.get("about:webrtc")
        self.vars.driver.set_window_size(int(1765/2), int(1158/2))

        video_info = self.vars.driver.execute_script("a = navigator.mediaDevices.getUserMedia({ video: true}).then(function (stream) { if (stream.getVideoTracks().length > 0 ){ return stream.getVideoTracks() } else { return 0 }}).catch(function (error) { return error}); return a")
        time.sleep(1)
        logging.debug(f"Returned by JS: {video_info}")
        
        video_info = str(video_info) # Given as a list, but we want a string, so we can use the "in" operator
        if video_info == "0":
            logging.error("No video device found")
            raise Exception("No video device found")
        elif "ABORT_ERR" in video_info:
            logging.warning("getUserMedia failed with error. Was not able to verify that the webcam worked!")
            raise IOError("Can't verify that the webcam works")
        elif "'kind': 'video', 'label': 'Dummy video device (0x0000)'" in video_info and "'enabled': True" in video_info:
            logging.info("getUserMedia returned a video track, which is enabled. This means that the webcam works!")
        


        audio_info = self.vars.driver.execute_script("a = navigator.mediaDevices.getUserMedia({ audio: true}).then(function (stream) { if (stream.getAudioTracks().length > 0){ return stream.getAudioTracks() } else { return 0 }}).catch(function (error) { return error}); return a")
        time.sleep(1)
        logging.debug(f"Returned by JS: {audio_info}")
        
        audio_info = str(audio_info)
        if audio_info == "0":
            logging.error("No audio device found")
            raise Exception("No audio device found")
        elif "ABORT_ERR" in audio_info:
            logging.warning("getUserMedia failed with error. Was not able to verify that the webcam mic worked!")
            raise IOError("Can't verify that the webcam mic works")
        elif "'kind': 'audio', 'label': 'virtual_mic'" in audio_info and "'enabled': True" in audio_info:
            logging.info("getUserMedia returned a audio track, which is enabled. This means that the webcam mic works!")
        
        self.vars.state = states["check_webrtc_settings"]

        if self.vars.driver.title == 'WebRTC Internals':
            # We are on the webRTC page
            ice_relay_only_str = "media.peerconnection.ice.relay_only"
            permission_disabled_str = "media.navigator.permission.disabled"

            relay_only , permissions = None, None

            if ice_relay_only_str in self.vars.driver.page_source:
                relay_only = ice_relay_only_str+": true" in self.vars.driver.page_source
            
            if permission_disabled_str in self.vars.driver.page_source:
                permissions = permission_disabled_str+": true" in self.vars.driver.page_source
            
            if not permissions and relay_only:
                logging.info("Browser settings:"+ice_relay_only_str+":"+str(relay_only)+" - "+permission_disabled_str+":"+str(permissions))
            else:
                logging.warning("Browser settings should be 'True':"+ice_relay_only_str+":"+str(relay_only)+" - "+permission_disabled_str+":"+str(permissions))
        else:
            logging.warning("Was not able to go to about:webrtc to check permissions!!!")
            


        URL = f"https://thomsen-it.dk/#/call/{self.vars.client_username}/{self.vars.room_id}"
        self.vars.state = states["starting_session"]
        logging.info(f"Starting session by navigating to '{URL}'")
        
        self.vars.driver.get(f"{URL}")

        if self.vars.driver.title == 'React App':
            # We are on the webRTC application page
            logging.info("We are on the webRTC application page")

            # Find client id in text FIXME: use find_element when implemented into app
            self.vars.client_id = "client_id2"
            if "Client Id:" in self.vars.driver.page_source:
                self.vars.client_id = self.vars.driver.page_source.split("Client Id: ")[1].split("</label>")[0]



                
            data["logging_type"] = logging_types["CLIENT_START"]
            create_client_report(data)
            

            # Starting test
            WebDriverWait(self.vars.driver, 30).until(
                expected_conditions.visibility_of_element_located((By.CSS_SELECTOR, ".ip > .value")))
            WebDriverWait(self.vars.driver, 30).until(
                expected_conditions.visibility_of_element_located((By.CSS_SELECTOR, ".country > .value")))
            self.vars.wanIp = self.vars.driver.find_element(
                By.CSS_SELECTOR, ".ip > .value").text
            self.vars.country = self.vars.driver.find_element(
                By.CSS_SELECTOR, ".country > .value").text
            self.vars.region = self.vars.driver.find_element(
                By.CSS_SELECTOR, ".region > .value").text
            self.vars.city = self.vars.driver.find_element(
                By.CSS_SELECTOR, ".city > .value").text
            self.vars.isp = self.vars.driver.find_element(
                By.CSS_SELECTOR, ".isp > .value").text


            logging.info(self.vars.wanIp + " " + self.vars.country + " " +
                self.vars.region + " " + self.vars.city + " " + self.vars.isp)



            retry_counter = 0
            waiting_counter = 0
            session_setup_retries = self.vars.session_setup_retries

            self.vars.state = states["waiting_for_call"]

            # If we have set the proxy and the client knows that it is a Tor Client
            if self.vars.proxy: # FIXME: "and "TOR" in self.vars.client_config"
                logging.info("Starting Tor circuit subscriber")
                setup_event_streamer(self.vars,logging)
                logging.info("Done starting Tor circuit subscriber")
                
            # Waiting for the call to start by checking if the video element is visible
            try:
                while "<tr><td><p>Connection state:</p></td><td><p>connected</p></td></tr>" not in self.vars.driver.page_source:
                    logging.info(f"Waiting for the call to start.. #{waiting_counter} out of ")
                    time.sleep(5)
                    

                    if "<tr><td><p>Connection state:</p></td><td><p>failed</p></td></tr>" in self.vars.driver.page_source:
                        logging.error("Connection state is failed. This means that the connection failed to start. Refreshing the page and trying again")
                        self.vars.driver.refresh()
                        waiting_counter = 0


                    waiting_counter += 1
                    
                    if waiting_counter > self.waiting_counter_max:
                        waiting_counter = 0
                        logging.info(f"Refreshing the page to check if the call just needed a restart! #{retry_counter} out of {session_setup_retries}")
                        self.vars.driver.refresh()
                        retry_counter += 1
                        if retry_counter > session_setup_retries:
                            logging.warning(f"Call did not start after {session_setup_retries} retries! Session failed!")

                            return
            except KeyboardInterrupt:
                logging.info("Skipping waiting for call to start caused by keyboard interrupt")
            

            self.vars.state = states["call_in_progress"]
            data["logging_type"] = logging_types["CLIENT_RUNNING"]
            create_client_report(data)

            logging.info(f"Waiting for {self.vars.session_length_seconds} seconds to see if the call is working.. Press CTRL+C to end the test early!")
            # Implement while loop with time.sleep(1) and check if the call is still working
            # Check if session_length_seconds is overdue.
            try:
                time.sleep(self.vars.session_length_seconds)
            except KeyboardInterrupt:
                logging.info("Skipping waiting for call to end caused by keyboard interrupt")
            

            self.vars.state = states["call_ended"]
            data["logging_type"] = logging_types["CLIENT_END"] # CLIENT_ERROR CLIENT_RUNNING
        

        else:
            logging.warning("Was not able to confirm that we are on the React App!!!")
            data["logging_type"] = logging_types["CLIENT_ERROR"]
            data["error"] = f"Could not go to the React App page. Title was '{self.vars.driver.title}'"

        try:
            # Close the Tor event listener and save the data reported from the last session
            self.vars.latest_circuit = close_event_streamer()
        except (Exception) as e:
            logging.error(f"Exception: {e}")
            data["logging_type"] = logging_types["CLIENT_ERROR"]
            data["error"] = f"Exception: {e}"

        create_client_report(data)

        return self.vars



if __name__ == "__main__":
    result = pyfiglet.figlet_format("OnionRTC")
    print(result)

    o = OnionRTC()

    try:
        o.setup_session()
        o.run_session()    
        o.clean_up()
    except (Exception,KeyboardInterrupt) as e:
        logging.error(f"Exception: {e}")
        o.vars.state = states["error"]
        o.vars.exception = e
        try:
            o.clean_up()
        except:
            pass

    logging.info(f"Printing variables: {o.vars}")
    